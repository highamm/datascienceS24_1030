---
title: "Section 3: dplyr"
author: "Matt Higham"
format: 
  html:
    embed-resources: true
---

```{r}
library(babynames)
library(tidyverse)
babynames
```

Class Exercises 1 and 2

```{r}
babynames_2017m <- babynames |> filter(year == 2017 & sex == "M") |>
  arrange(desc(n)) |>
  slice(1:10)

ggplot(data = babynames_2017m, aes(x = name, y = n)) +
  geom_col()
```

Class Exercises 3 and 4

```{r}
babynames_john <- babynames |> filter(name == "John" & sex == "M")
ggplot(data = babynames_john, aes(x = year, y = n)) +
  geom_line() ##+
  ##geom_smooth()
```

Class Exercise 5.

fitness_df |> mean(distance) is equivalent to mean(fitness_df, distance), but, the first argument to mean has to be a variable, not a data frame. 

Your Turn 1.

```{r}
babynames_not45 <- babynames |> filter(year != 1945)
babynames_whatever_n <- babynames |> filter(n >= 400 & n <= 5000)
```

Your Turn 2.

```{r}
babynames_monhil <- babynames |>
  filter(name == "Monica" | name == "Hilary") |>
  filter(sex == "F")

ggplot(data = babynames_monhil, aes(x = year, y = n)) +
  geom_line(aes(colour = name))
```

Your Turn 3

```{r}
babynames_5 <- babynames |> filter((name == "Matthew" & sex == "M") |
                      (name == "Jessica" & sex == "F") |
                      (name == "Robin" & sex == "M") |
                      (name == "Lillian" & sex == "F") |
                      (name == "Ivan" & sex == "M"))
ggplot(data = babynames_5, aes(x = year, y = n)) +
  geom_line(aes(colour = name))
```

Your Turn 4

```{r}
babynames_top2004 <- babynames |> filter(year == 2004 & sex == "M") |>
  arrange(desc(n)) |>
  slice(1:10)

ggplot(data = babynames_top2004, aes(x = name, y = n)) +
  geom_col(colour = "goldenrod4", fill = "goldenrod1")
```

```{r}
library(tidyverse)
slumajors_df <- read_csv("https://raw.githubusercontent.com/highamm/ds234_quarto/main/data_online/SLU_Majors_17_21.csv")
slumajors_df

slumajors_df <- slumajors_df |>
  mutate(ntotal = nfemales + nmales) |>
  mutate(percfemale = 100 * nfemales / (nfemales + nmales))
slumajors_df <- slumajors_df |>
  mutate(morewomen = if_else(percfemale > 50,
                             true = "Yes",
                             false = "No")) |>
  mutate(large_majority =
           case_when(percfemale >= 70 ~ "female",
                     percfemale <= 30 ~ "male",
                     percfemale > 30 & percfemale < 70 ~ "none")) 
```
## Section 3.4: More Practice

Class Exercises 1 and 2.

Class Exercise 3.

```{r}
slumajors_df |> mutate(testcase = case_when(percfemale >= 40 ~ "Yes",
                                            percfemale > 60 ~ "No")) |>
  ##select(testcase, everything()) |>
  relocate(testcase)
## if there are overlapping conditions, the first condition receives
## priority (goes in order of the conditions specified)
## if none of the conditions are satisfied, an NA goes in.

slumajors_df |> mutate(testcase = case_when(percfemale >= 40 ~ "Yes",
                                            percfemale > 60 ~ "No",
                                            .default = "maybe")) |>
  ##select(testcase, everything()) |>
  relocate(testcase)
## .default assigns a value to any row that did not satisfy any of the
## conditions in case_when()
```

Class Exercise 4.

```{r}
babynames |> group_by(year, sex) |>
  mutate(rankvar = rank(desc(n))) |>
  filter(rankvar == 1) |>
  group_by(name) |>
  summarise(n_years = n()) |>
  arrange(desc(n_years))
```

Class Exercise 5.

```{r}
babynames |> group_by(year, sex) |>
  filter(n == max(n)) |>
  group_by(name) |>
  summarise(n_years = n()) |>
  arrange(desc(n_years))
```

Class Exercise 6.

```{r}
babynames_test <- babynames |>
  group_by(year, sex) |> mutate(ntest = n / prop)
babynames_test |> slice(1, 2, 3, 4, 5)
## this is returning 5 rows per group (276 * 5 = 1380)

## if I truly want just the first 5 rows
babynames_test |> ungroup() |>  ## drops the grouping structure
  slice(1, 2, 3, 4, 5)
```

Your Turn 1. Skip. see handwritten packet.

Your Turn 2.

```{r}
toy_df <- tibble(x = c(NA, 3, 4, 7),
                 y = c(1, 4, 3, 2),
                 z = c("A", "A", "B", NA))
toy_df

## a
toy_df |> mutate(x_over_y = x / y)
## row where x is NA gets assigned an NA

## b: arrange
toy_df |> arrange(x)
## NAs get put at the bottom

## c
toy_df |> filter(x < 5)
## filter() removes the NA values by default

## d
toy_df |> summarise(mean_x = mean(x))
## returns an NA if _any_ values of x are missing

## if you want to find the mean after removing NAs:
toy_df |> summarise(mean_x = mean(x, na.rm = TRUE))

## e
toy_df |> group_by(z) |>
  summarise(mean_x = mean(x))
## NA values for z are treated as their own group
```

Your Turn 3.

```{r}
## a: mutate(): generally safe: all we are doing is adding a new column

## b: arrange(): generally safe: again, we are not
## changing the data itself (just how it's ordered)

## c: filter(): generally unsafe (only safe if you know
## you never need to use the rows you've filtered out)

## d: summarise(): unsafe: summarise() completely changes the structure of the data.

# e: select(): only safe if you are sure that you will
## never use the columns that you've selected out.
```

Your Turn 4.

```{r}
slumajors_df |>
  summarise(meantotalmajor = mean(ntotal),
            totalgrad = sum(ntotal)) 
slumajors_df |>
  mutate(meantotalmajor = mean(ntotal),
            totalgrad = sum(ntotal)) |>
  select(meantotalmajor, totalgrad, everything())
```

mutate() just adds a new column but the resulting data set always has the same number of rows as the original. summarise() collapses the data so that there is one row per group (there are no groups here, so 1 row total) and columns for any grouping variables (0 here) as well as the new summary variables.

